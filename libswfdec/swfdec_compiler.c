#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdlib.h>
#include <string.h>

#include <js/jsapi.h>
#include <js/jsatom.h>
#include <js/jsscript.h>
#include <js/jsopcode.h>

#include "swfdec_bits.h"
#include "swfdec_compiler.h"
#include "swfdec_debug.h"
#include "swfdec_decoder.h"
#include "swfdec_sprite.h"

/*** NOTE TO HACKERS ***

  This file is supposed to contain a compiler that compiles ActionScript code
  as found in an swf file to Javascript bytecode ready to be interpreted by 
  the Spidermonkey engine.
  The problem here is that I have not much of a clue on how to do such a thing 
  right, the SpiderMonkey docs are very nice for users but unfortunately not for 
  people mocking with bytecode. I guess the contents of this file reflects that. 
  So if you can do better, this file has just one public function: 
  swfdec_compile (). Feel free to reimplement it in a better way.

 *** END NOTE TO HACKERS ***/

/*** COMPILE STATE ***/

typedef struct {
  guint			bytecode;	/* offset into bytecode where jump address goes */
  gboolean		extended;	/* if this is an extended jump */
  guint			offset;		/* action to jump to */
} Jump;

typedef struct {
  SwfdecDecoder *	s;		/* decoder (contains JSContext!) */
  JSAtomList		atoms;		/* accumulated atoms */
  GByteArray *		bytecode;	/* generated bytecode so far */
  char *		error;		/* error encountered while compiling */
  GArray *		offsets;	/* offsets of actions */
  GArray *		jumps;		/* accumulated jumps */
} CompileState;

static void
compile_state_error (CompileState *state, char *format, ...) G_GNUC_PRINTF (2, 3);
static void
compile_state_error (CompileState *state, char *format, ...)
{
  va_list args;

  g_assert (state->error == NULL);

  va_start (args, format);
  state->error = g_strdup_vprintf (format, args);
  va_end (args);
}

/*** ACTION COMPILATION FUNCTIONS ***/

static void
compile_state_push_offset (CompileState *state)
{
  guint offset = state->bytecode->len;
  g_array_append_val (state->offsets, offset);
}

static void
compile_state_init (SwfdecDecoder *dec, CompileState *state)
{
  state->s = dec;
  ATOM_LIST_INIT (&state->atoms);
  state->bytecode = g_byte_array_new ();
  state->error = NULL;
  state->offsets = g_array_new (FALSE, FALSE, sizeof (guint));
  state->jumps = g_array_new (FALSE, FALSE, sizeof (Jump));

  compile_state_push_offset (state);
}

static void
compile_state_resolve_jumps (CompileState *state)
{
  guint i;
  int offset;
  Jump *jump;
  guint8 *bytecode;

  for (i = 0; i < state->jumps->len; i++) {
    jump = &g_array_index (state->jumps, Jump, i);
    bytecode = state->bytecode->data + jump->bytecode + 1;
    offset = g_array_index (state->offsets, guint, 
	MIN (state->offsets->len, jump->offset)); 
    offset -= jump->bytecode;
    if (jump->extended) {
      gint32 *data = (gint32 *) bytecode;
      *data = GINT32_TO_BE (offset);
    } else {
      gint16 *data = (gint16 *) bytecode;
      if (offset > G_MAXINT32 || offset < G_MININT32) {
	compile_state_error (state, "jump from %u to %u is too big\n",
	  jump->bytecode, MIN (state->offsets->len, jump->offset));
	return;
      }
      *data = GINT16_TO_BE (offset);
    }
  }
}

static JSScript *
compile_state_finish (CompileState *state)
{
  JSContext *cx = state->s->jscx;
  JSScript *script = NULL;

  if (state->error == NULL)
    compile_state_resolve_jumps (state);

  if (state->error != NULL) {
    JSAtomMap clear;
    js_InitAtomMap (cx, &clear, &state->atoms);
    js_FreeAtomMap (cx, &clear);
    g_print ("%s\n", state->error);
    g_free (state->error);
    goto cleanup;
  }

  script = js_NewScript (cx, state->bytecode->len, 1, 1);
  memcpy (script->code, state->bytecode->data, state->bytecode->len);
  js_InitAtomMap (cx, &script->atomMap, &state->atoms);
  /* FIXME: compute the max stack depth correctly! */
  script->depth = 100;

cleanup:
  g_array_free (state->offsets, TRUE);
  g_array_free (state->jumps, TRUE);
  g_byte_array_free (state->bytecode, TRUE);
  return script;
}

/* must be called before adding the jump command to the bytecode */
static void
compile_state_add_jump (CompileState *state, int n_actions, gboolean extended)
{
  Jump jump = { state->bytecode->len, extended, state->offsets->len + n_actions };

  if (n_actions < 0 && state->offsets->len < (guint) -n_actions) {
    compile_state_error (state, "attempting to jump %d actions backwards in %u. action",
	-n_actions, state->offsets->len);
    return;
  }
  g_array_append_val (state->jumps, jump);
}

static void
compile_state_add_code (CompileState *state, const guint8 *code, guint len)
{
  if (state->error)
    return;
  g_byte_array_append (state->bytecode, code, len);
}

#define ONELINER(state, opcode) G_STMT_START { \
  guint8 command = opcode; \
  compile_state_add_code (state, &command, 1); \
} G_STMT_END
#define PUSH_OBJ(state) ONELINER (state, JSOP_PUSHOBJ)
#define POPV(state) ONELINER (state, JSOP_POPV)
#define GE(state) ONELINER (state, JSOP_GE)

#define DO_JUMP(state, opcode, offset) G_STMT_START {\
  guint8 command[3] = { opcode, 0, 0 }; \
  compile_state_add_jump (state, offset, FALSE); \
  compile_state_add_code (state, command, 3); \
} G_STMT_END
#define IFEQ(state, offset) DO_JUMP (state, JSOP_IFEQ, offset)

static jsatomid
atomize_string (CompileState *state, const char *name)
{
  JSAtom *atom;
  JSAtomListElement *ale;

  atom = js_Atomize (state->s->jscx, name, strlen (name), 0);
  ale = js_IndexAtom (state->s->jscx, atom, &state->atoms);
  if (ale == NULL) {
    compile_state_error (state, "Failed to add _root object");
    return 0;
  }
  return ALE_INDEX (ale);
}
    
static void
push_root (CompileState *state)
{
  jsatomid id;
  guint8 command[3];

  id = atomize_string (state, "_root");
  command[0] = JSOP_NAME;
  command[1] = id >> 8;
  command[2] = id;
  compile_state_add_code (state, command, 3);
}

static void
push_prop (CompileState *state, const char *name)
{
  jsatomid id;
  guint8 command[3];

  id = atomize_string (state, name);
  command[0] = JSOP_GETPROP;
  command[1] = id >> 8;
  command[2] = id;
  compile_state_add_code (state, command, 3);
}

static void
push_uint16 (CompileState *state, unsigned int i)
{
  guint8 command[3] = { JSOP_UINT16, i >> 8, i };
  g_assert (i <= G_MAXUINT16);
  compile_state_add_code (state, command, 3);
}

static void
read_and_push_uint16 (CompileState *state)
{
  push_uint16 (state, swfdec_bits_get_u16 (&state->s->b));
}

static void
call (CompileState *state, guint n_arguments)
{
  guint8 command[3] = { JSOP_CALL, n_arguments >> 8, n_arguments };
  compile_state_add_code (state, command, 3);
}

static void
call_void_function (CompileState *state, const char *name)
{
  push_prop (state, name);
  PUSH_OBJ (state);
  call (state, 0);
  POPV (state);
}

static void
compile_goto_frame (CompileState *state, guint action, guint len)
{
  push_root (state);
  push_prop (state, "gotoAndStop");
  PUSH_OBJ (state);
  read_and_push_uint16 (state);
  call (state, 1);
  POPV (state);
}

static void
compile_wait_for_frame (CompileState *state, guint action, guint len)
{
  push_root (state);
  push_prop (state, "_framesloaded");
  read_and_push_uint16 (state);
  GE (state);
  IFEQ (state, swfdec_bits_get_u8 (&state->s->b));
}

static void
compile_simple_call (CompileState *state, guint action, guint len)
{
  char *name;

  push_root (state);
  switch (action) {
    case 0x06:
      name = "play";
      break;
    case 0x07:
      name = "stop";
      break;
    default:
      g_assert_not_reached ();
      return;
  }
  call_void_function (state, name);
}

/*** COMPILER ***/

typedef struct {
  guint action;
  const char *name;
  void (* compile) (CompileState *state, guint action, guint len);
} SwfdecActionSpec;

static const SwfdecActionSpec * swfdec_action_find (guint action);

void
swfdec_disassemble (SwfdecDecoder *s, JSScript *script)
{
  guint i;

  for (i = 0; i < script->length; i ++) {
    g_print ("%02X ", script->code[i]);
    if (i % 16 == 15)
      g_print ("\n");
    else if (i % 4 == 3)
      g_print (" ");
  }
  if (i % 16 != 15)
    g_print ("\n");
  js_Disassemble (s->jscx, script, JS_TRUE, stdout);
}

/**
 * swfdec_compile:
 * @s: a #SwfdecDecoder during parsing
 *
 * continues parsing the current file and compiles the ActionScript commands 
 * encountered into a script for later execution.
 *
 * Returns: A new JSScript or NULL on failure
 **/
JSScript *
swfdec_compile (SwfdecDecoder *s)
{
  unsigned int action, len;
  const SwfdecActionSpec *current;
  SwfdecBits *bits;
  CompileState state;
  JSScript *ret;

  g_return_val_if_fail (s != NULL, NULL);

  compile_state_init (s, &state);
  bits = &s->b;
  SWFDEC_LOG ("Creating new script in frame %d", s->parse_sprite->parse_frame);
  while ((action = swfdec_bits_get_u8 (bits))) {
    if (action & 0x80) {
      len = swfdec_bits_get_u16 (bits);
    } else {
      len = 0;
    }
    current = swfdec_action_find (action);
    SWFDEC_DEBUG ("compiling action %d %s", action, current ? current->name : "unknown");
    if (state.error == NULL && current && current->compile) {
      current->compile (&state, action, len);
      compile_state_push_offset (&state);
    } else {
      swfdec_bits_getbits (bits, len * 8);
      if (state.error == NULL) {
	if (current) {
	  compile_state_error (&state, "No compilation function for %s action", current->name);
	} else {
	  compile_state_error (&state, "unknown action 0x%02X", action);
	}
      }
    }
  }
  ret = compile_state_finish (&state);
#if 0
  if (ret)
    swfdec_disassemble (s, ret);
#endif

  return ret;
}

/* must be sorted! */
SwfdecActionSpec actions[] = {
  /* version 3 */
  { 0x04, "NextFrame", NULL },
  { 0x05, "PreviousFrame", NULL },
  { 0x06, "Play", compile_simple_call },
  { 0x07, "Stop", compile_simple_call },
  { 0x08, "ToggleQuality", NULL },
  { 0x09, "StopSounds", NULL },
  /* version 4 */
  { 0x0a, "Add", NULL },
  { 0x0b, "Subtract", NULL },
  { 0x0c, "Multiply", NULL },
  { 0x0d, "Divide", NULL },
  { 0x0e, "Equals", NULL },
  { 0x0f, "Less", NULL },
  { 0x10, "And", NULL },
  { 0x11, "Or", NULL },
  { 0x12, "Not", NULL },
  { 0x13, "StringEquals", NULL },
  { 0x14, "StringLength", NULL },
  { 0x15, "StringExtract", NULL },
  { 0x17, "Pop", NULL },
  { 0x18, "ToInteger", NULL },
  { 0x1c, "GetVariable", NULL },
  { 0x1d, "SetVariable", NULL },
  { 0x20, "SetTarget2", NULL },
  { 0x21, "StringAdd", NULL },
  { 0x22, "GetProperty", NULL },
  { 0x23, "SetProperty", NULL },
  { 0x24, "CloneSprite", NULL },
  { 0x25, "RemoveSprite", NULL },
  { 0x26, "Trace", NULL },
  { 0x27, "StartDrag", NULL },
  { 0x28, "EndDrag", NULL },
  { 0x29, "StringLess", NULL },
  /* version 7 */
  { 0x2a, "Throw", NULL },
  { 0x2b, "Cast", NULL },
  { 0x2c, "Implements", NULL },
  /* version 4 */
  { 0x30, "RandomNumber", NULL },
  { 0x31, "MBStringLength", NULL },
  { 0x32, "CharToAscii", NULL },
  { 0x33, "AsciiToChar", NULL },
  { 0x34, "GetTime", NULL },
  { 0x35, "MBStringExtract", NULL },
  { 0x36, "MBCharToAscii", NULL },
  { 0x37, "MVAsciiToChar", NULL },
  /* version 5 */
  { 0x3a, "Delete", NULL },
  { 0x3b, "Delete2", NULL },
  { 0x3c, "DefineLocal", NULL },
  { 0x3d, "CallFunction", NULL },
  { 0x3e, "Return", NULL },
  { 0x3f, "Modulo", NULL },
  { 0x40, "NewObject", NULL },
  { 0x41, "DefineLocal2", NULL },
  { 0x42, "InitArray", NULL },
  { 0x43, "InitObject", NULL },
  { 0x44, "Typeof", NULL },
  { 0x45, "TargetPath", NULL },
  { 0x46, "Enumerate", NULL },
  { 0x47, "Add2", NULL },
  { 0x48, "Less2", NULL },
  { 0x49, "Equals2", NULL },
  { 0x4a, "ToNumber", NULL },
  { 0x4b, "ToString", NULL },
  { 0x4c, "PushDuplicate", NULL },
  { 0x4d, "Swap", NULL },
  { 0x4e, "GetMember", NULL },
  { 0x4f, "SetMember", NULL },
  { 0x50, "Increment", NULL },
  { 0x51, "Decrement", NULL },
  { 0x52, "CallMethod", NULL },
  { 0x53, "NewMethod", NULL },
  /* version 6 */
  { 0x54, "InstanceOf", NULL },
  { 0x55, "Enumerate2", NULL },
  /* version 5 */
  { 0x60, "BitAnd", NULL },
  { 0x61, "BitOr", NULL },
  { 0x62, "BitXor", NULL },
  { 0x63, "BitLShift", NULL },
  { 0x64, "BitRShift", NULL },
  { 0x65, "BitURShift", NULL },
  /* version 6 */
  { 0x66, "StrictEquals", NULL },
  { 0x67, "Greater", NULL },
  { 0x68, "StringGreater", NULL },
  /* version 7 */
  { 0x69, "Extends", NULL },

  /* version 3 */
  { 0x81, "GoToFrame", compile_goto_frame },
  { 0x83, "GetURL", NULL },
  /* version 5 */
  { 0x87, "StoreRegister", NULL },
  { 0x88, "ConstantPool", NULL },
  /* version 3 */
  { 0x8a, "WaitForFrame", compile_wait_for_frame },
  { 0x8b, "SetTarget", NULL },
  { 0x8c, "GoToLabel", NULL },
  /* version 4 */
  { 0x8d, "WaitForFrame2", NULL },
  /* version 7 */
  { 0x8e, "DefineFunction2", NULL },
  { 0x8f, "Try", NULL },
  /* version 5 */
  { 0x94, "With", NULL },
  /* version 4 */
  { 0x96, "Push", NULL },
  { 0x99, "Jump", NULL },
  { 0x9a, "GetURL2", NULL },
  /* version 5 */
  { 0x9b, "DefineFunction", NULL },
  /* version 4 */
  { 0x9d, "If", NULL },
  { 0x9e, "Call", NULL },
  { 0x9f, "GotoFrame2", NULL }
};

int
uint_compare (gconstpointer v1, gconstpointer v2)
{
  return *((const unsigned int*) v1) - *((const unsigned int*) v2);
}

static const SwfdecActionSpec *
swfdec_action_find (guint action)
{
  return bsearch (&action, actions, G_N_ELEMENTS (actions), 
      sizeof (SwfdecActionSpec), uint_compare);
}
